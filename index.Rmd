---
title: "Camera Height vs Volume Width Study"
author: "Jereme Outerleys"
date: "`r Sys.Date()`"
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
set.seed(123)  # for reproducibility
library(fst)
library(here)
library(dplyr)
library(tidyr)
library(ggplot2)
library(plotly)
library(htmlwidgets)
library(ggiraph)
knitr::opts_chunk$set(echo = TRUE, fig.width = 10, fig.height = 5)
```

## Study Overview

The objective of this study was to investigate the affect of camera height as a function of volume width on lower limb kinematics during normal walking using Theia3D. Video data was recorded for 9 subjects using 32 Sony RX0II cameras and processed in Theia3D (v2023.1.0.3161p9, model v10.0.0, 3DOF knee, 8 Hz cutoff frequency).

**Camera Heights and Volume widths**

**Camera Heights**\
The 32 cameras were placed in a standard ellipse-like configuration (see [Figure 1](#Fig1)). Cameras were placed at 4 heights for each camera location:

-   Group 1: 0.85m (hip height)
-   Group 2: 1.65m (shoulder/head)
-   Group 3: 2.45m (HMRL standard setup)
-   Group 4: 3.30m (HMRL Scaffold Rig)

Group 0 included all 32 cameras during processing.

**Volume Width**\
For each width the cameras were moved and re-aimed to get the subject in all camera views as much as possible given the width constraints.

Width 1 was the standard HMRL volume length (\~13.8m Long) and width. Width 2 and 3 were narrower. With width 3 trying to simulate hallway.

-   Width 1: 6.9 m
-   Width 2: 5.5 m
-   Width 3: 3.3 m (not added yet)

A 5th and 6th group were added to Width 3 since the sagittal cameras for groups 1 and 2 could not get the full subjects. The sagittal cameras were replaced with videos from group 3.

![Width 1 Camera Groupings.](images/Fig1.PNG){#Fig1}

**Calibration**\
A single calibration was performed for each width with all 32 cameras. Separate calibration files were then built by extracting the cameras for each group.

```{r import, echo=FALSE, message=FALSE}

# load main fst
#fst_file <- list.files(file.path(here(),'chkpts'), pattern = "*.fst", full.names = TRUE) %>% sort(decreasing = TRUE)

fst_file <- "H:\\MultiCam\\r_projects\\2204_04_18_Multicam\\chkpts\\2024-04-19-120705_multicam.fst"
df <- read.fst(fst_file)

# Select waveforms only
waveform_list <- c('PELVIS_ANGLE','HIP_ANGLE','KNEE_ANGLE','ANKLE_ANGLE')

df_waveforms <- df %>%
  filter(signal_names %in% waveform_list) %>%
  select(-signal_types, -signal_folder, -action, -trial) %>%
  mutate(item = item - 1) %>% # for plots
  filter(signal_side == 'RIGHT')

df_waveforms$signal_names <- ordered(df_waveforms$signal_names, levels = waveform_list)

missing = which(complete.cases(df_waveforms) == FALSE)
missing <- df_waveforms[missing,]
#unique(missing[c("subject","trial","signal_side","signal_names")])

#unique(df_waveforms$subject)
#unique(df_waveforms$width)
#unique(df_waveforms$group)

# Ensemble Waveforms: width:group:subject:side
# tidy (slow)
df_waveforms_subject_mean <- df_waveforms %>% 
  group_by(width,group,subject,signal_side,signal_names,signal_components,item) %>%
  summarise(value = mean(value), .groups = 'drop')

# Ensemble Waveforms: width:group
# tidy (slow)
df_waveforms_group_mean <- df_waveforms_subject_mean %>% 
  group_by(width,group,signal_side,signal_names,signal_components,item) %>%
  summarise(value = mean(value), .groups = 'drop')

component_names <- c(
  `X`="Flex/Ext.",
  `Y`="Add/Abduction",
  `Z` = "Int/Ext Rotation" )


```

## Ensemble average plots by camera height (group) and volume width.

Data only shown for Right Leg.\
The plots are interactive:

-   Click and drag to zoom.
-   Hover over the line to see the group.

Draft interpretations per Jereme and Rob:

-   Height doesn't look to cause large differences, at least at these two widths (narrowest width still processing).
-   The largest differences exist between the lowest and the highest height as expected.
-   Data for all 36 cameras falls inbetwen as expected.
-   Doesn't seem to be a specific, consistent effect of width for any camera height.
-   Lower cameras are generally less affected than higher ones, except during swing.
-   For a balanced setup (i.e. all cameras or maybe just having cameras at multiple heights), there is almost no effect of width.
-   Camera height adjusts the offset/starting point/average of the signals up or down, with low cameras having more ext. rot and high cameras having less.
-   Looks like the leg axial rotation moves from being accounted for in the knee to the hip as the camera height increases. Results in opposite effects of height on those two joints.

```{r width_group_averages_pelvis, echo=FALSE}
# Ensemble Waveforms: width:group
plot <- df_waveforms_group_mean %>%
  #filter(width == "Width2") %>%
  filter(group != "Group0") %>%
  filter(signal_names == "PELVIS_ANGLE") %>%
  #filter(signal_components == 'Z') %>%
  #group_by(width,item) %>%
  #mutate(value = scale(value, center = TRUE, scale = FALSE)) %>%
  #ungroup() %>%
  #filter(item < 60) %>%
  #filter(signal_components == 'X' | signal_components == 'Y' ) %>%
  #ggplot(aes(x = item, y = value, color = group, label = group)) +
  ggplot(aes(x = item, y = value, linetype = width, color = group, text = paste(width, group))) +
  geom_hline(yintercept=0, color = "black", linewidth=0.25)+
  stat_summary(fun = mean, geom = "line", linewidth = 0.5) +
  #stat_summary(fun.data="mean_sdl", fun.args = list(mult = 1), mapping = aes(color = group, fill = group), geom = "ribbon", alpha = 0.1, colour = NA)+
  facet_wrap(signal_names~ signal_components, scales="free", ncol = 3,labeller = labeller(signal_components = as_labeller(component_names)))+
  theme_minimal()+
  theme(axis.line = element_line(linewidth = 1, colour = "black"),
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        #strip.text = element_text(size = 14, face = "bold", colour = "black"),  
        #axis.text.y = element_text(size = 14, face = "bold", colour = "black"), 
        #axis.text.x = element_text(size = 14, face = "bold", colour = "black"),
        #panel.spacing = unit(2, "lines"),
        #plot.margin = margin(0, 0.5, 0, 0, "cm"),
        legend.position = "none") +
    scale_x_continuous(expand = c(0, 0))

ggplotly(plot, tooltip = c('text'))

```

```{r width_group_averages_hip, echo=FALSE}
# Ensemble Waveforms: width:group
plot <- df_waveforms_subject_mean %>%
  #filter(width == "Width2") %>%
  filter(group != "Group0") %>%
  filter(signal_names == "HIP_ANGLE") %>%
  #filter(signal_components == 'Z') %>%
  #group_by(width,item) %>%
  #mutate(value = scale(value, center = TRUE, scale = FALSE)) %>%
  #ungroup() %>%
  #filter(item < 60) %>%
  #filter(signal_components == 'X' | signal_components == 'Y' ) %>%
  #ggplot(aes(x = item, y = value, color = group, label = group)) +
  ggplot(aes(x = item, y = value, linetype = width, color = group, text = paste(width, group))) +
  geom_hline(yintercept=0, color = "black", linewidth=0.25)+
  stat_summary(fun = mean, geom = "line", linewidth = 0.5) +
  #stat_summary(fun.data="mean_sdl", fun.args = list(mult = 1), mapping = aes(color = group, fill = group), geom = "ribbon", alpha = 0.1, colour = NA)+
  facet_wrap(signal_names~ signal_components, scales="free", ncol = 3,labeller = labeller(signal_components = as_labeller(component_names)))+
  theme_minimal()+
  theme(axis.line = element_line(linewidth = 1, colour = "black"),
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        #strip.text = element_text(size = 14, face = "bold", colour = "black"),  
        #axis.text.y = element_text(size = 14, face = "bold", colour = "black"), 
        #axis.text.x = element_text(size = 14, face = "bold", colour = "black"),
        #panel.spacing = unit(2, "lines"),
        #plot.margin = margin(0, 0.5, 0, 0, "cm"),
        legend.position = "none") +
    scale_x_continuous(expand = c(0, 0))

ggplotly(plot, tooltip = c('text'))


```

```{r width_group_averages_knee, echo=FALSE}
# Ensemble Waveforms: width:group
plot <- df_waveforms_subject_mean %>%
  #filter(width == "Width2") %>%
  filter(group != "Group0") %>%
  filter(signal_names == "KNEE_ANGLE") %>%
  #filter(signal_components == 'Z') %>%
  #group_by(width,item) %>%
  #mutate(value = scale(value, center = TRUE, scale = FALSE)) %>%
  #ungroup() %>%
  #filter(item < 60) %>%
  #filter(signal_components == 'X' | signal_components == 'Y' ) %>%
  #ggplot(aes(x = item, y = value, color = group, label = group)) +
  ggplot(aes(x = item, y = value, linetype = width, color = group, text = paste(width, group))) +
  geom_hline(yintercept=0, color = "black", linewidth=0.25)+
  stat_summary(fun = mean, geom = "line", linewidth = 0.5) +
  #stat_summary(fun.data="mean_sdl", fun.args = list(mult = 1), mapping = aes(color = group, fill = group), geom = "ribbon", alpha = 0.1, colour = NA)+
  facet_wrap(signal_names~ signal_components, scales="free", ncol = 3,labeller = labeller(signal_components = as_labeller(component_names)))+
  theme_minimal()+
  theme(axis.line = element_line(linewidth = 1, colour = "black"),
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        #strip.text = element_text(size = 14, face = "bold", colour = "black"),  
        #axis.text.y = element_text(size = 14, face = "bold", colour = "black"), 
        #axis.text.x = element_text(size = 14, face = "bold", colour = "black"),
        #panel.spacing = unit(2, "lines"),
        #plot.margin = margin(0, 0.5, 0, 0, "cm"),
        legend.position = "none") +
    scale_x_continuous(expand = c(0, 0))

ggplotly(plot, tooltip = c('text'))

```

```{r width_group_averages_ankle, echo=FALSE}
# Ensemble Waveforms: width:group
plot <- df_waveforms_subject_mean %>%
  #filter(width == "Width2") %>%
  filter(group != "Group0") %>%
  filter(signal_names == "ANKLE_ANGLE") %>%
  #filter(signal_components == 'Z') %>%
  #group_by(width,item) %>%
  #mutate(value = scale(value, center = TRUE, scale = FALSE)) %>%
  #ungroup() %>%
  #filter(item < 60) %>%
  #filter(signal_components == 'X' | signal_components == 'Y' ) %>%
  #ggplot(aes(x = item, y = value, color = group, label = group)) +
  ggplot(aes(x = item, y = value, linetype = width, color = group, text = paste(width, group))) +
  geom_hline(yintercept=0, color = "black", linewidth=0.25)+
  stat_summary(fun = mean, geom = "line", linewidth = 0.5) +
  #stat_summary(fun.data="mean_sdl", fun.args = list(mult = 1), mapping = aes(color = group, fill = group), geom = "ribbon", alpha = 0.1, colour = NA)+
  facet_wrap(signal_names~ signal_components, scales="free", ncol = 3,labeller = labeller(signal_components = as_labeller(component_names)))+
  theme_minimal()+
  theme(axis.line = element_line(linewidth = 1, colour = "black"),
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        #strip.text = element_text(size = 14, face = "bold", colour = "black"),  
        #axis.text.y = element_text(size = 14, face = "bold", colour = "black"), 
        #axis.text.x = element_text(size = 14, face = "bold", colour = "black"),
        #panel.spacing = unit(2, "lines"),
        #plot.margin = margin(0, 0.5, 0, 0, "cm"),
        legend.position = "none") +
    scale_x_continuous(expand = c(0, 0))

ggplotly(plot, tooltip = c('text'))


```
